//http://processing.org/learning/basics/bezierellipse.html

// arrays to hold ellipse coordinate data
var px	=[];
var py	=[];
var cx	=[];
var cy	=[];
var cx2	=[];
var cy2	=[];

// global variable-povars in ellipse
var pts = 4;

var controlPtCol = "#222222";
var anchorPtCol = "#BBBBBB";

function setup(){
  size(200, 200);
  smooth();
  setEllipse(pts, 65, 65);
  frameRate(0.5);
}

function draw(){
  background(145);
  drawEllipse();
  setEllipse(parseInt(random(3, 12)), random(-100, 150), random(-100, 150));
}

// draw ellipse with anchor/control povars
function drawEllipse(){
  strokeWeight(1.125);
  stroke(255);
  noFill();
  // create ellipse
  for (var i=0; i<pts; i++){
    if (i==pts-1) {
      bezier(px[i], py[i], cx[i], cy[i], cx2[i], cy2[i],  px[0], py[0]);
    }
    else{
      bezier(px[i], py[i], cx[i], cy[i], cx2[i], cy2[i],  px[i+1], py[i+1]);
    }
  }
  strokeWeight(.75);
  stroke(0);
  rectMode("CENTER");

  // control handles and tangent lines
  for (var i=0; i< pts; i++){
    if (i==pts-1){  // last loop iteration-close path
      line(px[0], py[0], cx2[i], cy2[i]);
    }
    if (i>0){
      line(px[i], py[i], cx2[i-1], cy2[i-1]);
    }
    line(px[i], py[i], cx[i], cy[i]);
  }

  for (var i=0; i< pts; i++){
    fill(controlPtCol);
    noStroke();
    //control handles
    ellipse(cx[i], cy[i], 4, 4);
    ellipse(cx2[i], cy2[i], 4, 4);

    fill(anchorPtCol);
    stroke(0);
    //anchor povars
    rect(px[i], py[i], 5, 5);
  }
}

// fill up arrays with ellipse coordinate data
function setEllipse(povars, radius, controlRadius){
  pts = povars;
  px = new Array(povars);
  py = new Array(povars);
  cx = new Array(povars);
  cy = new Array(povars);
  cx2 = new Array(povars);
  cy2 = new Array(povars);
  var angle = 360.0/povars;
  var controlAngle1 = angle/3.0;
  var controlAngle2 = controlAngle1*2.0;
  for ( var i=0; i<povars; i++){
    px[i] = width/2+cos(radians(angle))*radius;
    py[i] = height/2+sin(radians(angle))*radius;
    cx[i] = width/2+cos(radians(angle+controlAngle1))*controlRadius/cos(radians(controlAngle1));
    cy[i] = height/2+sin(radians(angle+controlAngle1))*controlRadius/cos(radians(controlAngle1));
    cx2[i] = width/2+cos(radians(angle+controlAngle2))*controlRadius/cos(radians(controlAngle1));
    cy2[i] = height/2+sin(radians(angle+controlAngle2))*controlRadius/cos(radians(controlAngle1));

    //increment angle so trig functions keep chugging along
    angle+=360.0/povars;
  }
}